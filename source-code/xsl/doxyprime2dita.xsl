<?xml version="1.0" encoding="UTF-8"?>

<!-- ...................................................................... -->
<!-- File: doxyprime2dita.xsl                                               -->
<!--                                                                        -->
<!-- Purpose: Process most Doxygen XML elements to create valid DITA topics -->
<!--          and passes processing to templates in other XSLT files as     -->
<!--          necessary.                                                    -->
<!-- ...................................................................... -->
<!-- Notes/History:                                                         -->
<!-- 30.Jun.2011    Created.                                                -->
<!-- 06.Jul.2011    Added code to process struct reference information that -->
<!--                Doxygen generates in a file separate from the header    -->
<!--                information.                                            -->
<!-- 26.Sep.2011    Extensive update to create overview topics to allow for -->
<!--                grouping in the ditamap/TOC, and to handle the creation -->
<!--                of the 'Synopsis' reference sections more intelligently.-->
<!-- 29.Sep.2011    Minor changes to verbatim template to handle code for   -->
<!--                structs in a more general way.                          -->
<!-- 17.Jan.2012    Major changes to make transformations more general. Now -->
<!--                transforming a larger sample of Doxygen XML (for        -->
<!--                example, Scoreloop docs).                               -->
<!-- 07.Mar.2012    Minor changes to URIs to allow transformations to run   -->
<!--                on Windows as well as Mac OS.                           -->
<!-- 17.Mar.2012    Added templates to handle detaileddescription elements  -->
<!--                that are identified in the Doxygen source by @details   -->
<!--                tags.                                                   -->
<!-- 24.Mar.2012    Added condition for libscreen to apilib variable.       -->
<!-- 10.Apr.2012    Added code to prevent 'todo' items from being           -->
<!--                processed.                                              -->
<!-- 15.Apr.2012    Added code to create funtion/execution type tables for  -->
<!--                Screen lib ref plug-in.  This 'extension' code should   -->
<!--                eventually be extracted into its own file to keep the   -->
<!--                doxy2dita transformation code generic.                  -->
<!-- 28.May.2012    Corrected code that constructs path to open group file  -->
<!--                to get name for anonymous enum (removed file separator) -->
<!-- 29.May.2012    Made changes to accommodate new capability to specify   -->
<!--                custom source and output directories when invoking the  -->
<!--                transform from Ant.                                     -->
<!-- 29.May.2012    Various changes, additions, and corrections identified  -->
<!--                by writers using the transform. Added capability for    -->
<!--                user-specified library name.                            -->
<!-- 31.May.2012    Added code to process lists and links in enums.         -->
<!-- 19.Jun.2012    Added template to handle returns listed in @retval      -->
<!--                tags. Contibuted by Tim Howie.                          -->
<!-- 21.Jun.2012    Added template to process 'emphasis' elements generated -->
<!--                by @e Doxygen tags.                                     -->
<!-- 22.Jun.2012    Included scale attribute in 'pre' elements to try and   -->
<!--                keep API component names on one line in PDFs.           -->
<!-- 09.Aug.2012    Added code to handle links generated by Doxygen to      -->
<!--                enum members/values: id attributes to dlentry elements, -->
<!--                and new conditional code to ref template.               -->
<!-- 14.Aug.2012    Added code to handle creation of DITA files for over-   -->
<!--                loaded functions.                                       -->
<!-- 16.Aug.2012    Modified code to correct XPath expression for overload  -->
<!--                count in src/index.xml.                                 -->
<!-- 23.Oct.2012    Added code for enum linking among multiple files and    -->
<!--                identifying params specified in typedefs.               -->
<!-- 26.Oct.2012    Modified Synopsis template to handle include paths that -->
<!--                don't have a subdirectory under the root include        -->
<!--                location.                                               -->
<!-- 09.Nov.2012    Fixed regression issue -\- links in lists in detailed   -->
<!--                descriptions to enum members.                           -->
<!-- 29.Jan.2013    Added and modified code to provide support for @since   -->
<!--                tags in Doxygen comments.                               -->
<!-- 30.Jan.2013    Modified code to add structure [sectiondiv] elements to -->
<!--                generated Definitions files to provide more space       -->
<!--                between definitions in a single topic.                  -->
<!-- 01.Mar.2013    Added code to generate product attributes associated    -->
<!--                with @since information to restrict output to NDK only. -->
<!-- 13.Sep.2013    Modified code to include argstring information for      -->
<!--                data members.                                           -->
<!-- 27.Sep.2013    DEVSUPP-145: added template to convert Doxygen's bold   -->
<!--                element to DITA's b.                                    -->
<!-- 01.Oct.2013    Added templates to handle Doxygen bold and emphasis in  -->
<!--                paramlist mode.  This is a workaround that should be    -->
<!--                removed when the transform is refactored.               -->
<!-- ...................................................................... -->

<xsl:transform version="2.0" xmlns:xml="http://www.w3.org/XML/1998/namespace"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

    <!-- Included stylesheets ................................................. -->

    <!--<!-\- Processes the @mainpage comment, which becomes the overview topic 
         for the doc set. -\->
    <xsl:include href="doxymain2dita.xsl"/>
    
    <!-\- Creates introductory topics for API content. -\->
    <xsl:include href="doxyconcept2dita.xsl "/>
    
    <!-\- Creates topics from Doxygen XML 'group' pages. -\->
    <xsl:include href="doxygroup2dita.xsl "/>-->

    <!-- .................................................................. -->
    <!-- Root node template                                                 -->

    <!-- 
        Recursive template that processes the contents of each file 
        in an XML file that lists input files.
        
        The files in the list are the XML files that Doxygen generates from
        source code.
    -->
    <!--<xsl:template match="file">
        <xsl:param name="path">
            <xsl:value-of select="@absolutePath" />
        </xsl:param>
        <xsl:apply-templates select="document($path)/doxygen" />
        <xsl:apply-templates select="file" />
    </xsl:template>-->

    <!-- Suppress nodes that are not matched -->
    <!--<xsl:template match="text() | @*">
        <xsl:apply-templates select="text() | @*"/>
    </xsl:template>-->

    <xsl:template match="doxygen">
        <xsl:apply-templates select="compounddef" />
    </xsl:template>

    <!-- ...................................................................... -->
    <!-- Templates                                                              -->

    <!-- 
        API component type selection.
        
        This template determines which template(s) to use to begin processing
        of the input XML.
    -->
    <xsl:template match="compounddef">

        <xsl:choose>
            <!-- /////INDEXPAGE\\\\\ -->
            <xsl:when test="@id='indexpage'">
                <xsl:apply-templates mode="indexpage" select="detaileddescription">
                    <xsl:with-param name="ident">
                        <xsl:value-of select="@id" />
                    </xsl:with-param>
                </xsl:apply-templates>
            </xsl:when>
            <!-- /////PAGE\\\\\ -->
            <xsl:when test="@id != 'indexpage' and @kind='page'">
                <xsl:call-template name="create-about-page">
                    <xsl:with-param name="ident">
                        <xsl:value-of select="@kind" />
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <!-- /////GROUP\\\\\ -->
            <xsl:when test="@id != 'indexpage' and @kind='group'">
                <xsl:call-template name="create-group-page">
                    <xsl:with-param name="ident">
                        <xsl:value-of select="@kind" />
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:if test="contains(@id, 'screen') and @kind='file'">
                    <xsl:call-template name="funcTypesTable_driver" />
                </xsl:if>
                <xsl:apply-templates />
            </xsl:otherwise>
        </xsl:choose>

    </xsl:template>

    <xsl:template match="compoundname" />

    <!-- 
        Process includes.
    -->
    <xsl:template match="includes">
        <xsl:choose>
            <xsl:when test="not(following-sibling::sectiondef)">
                <xsl:variable name="outpath">
                    <xsl:choose>
                        <xsl:when test="contains(@id, struct)">
                            <xsl:value-of select="concat($outdir,  ../@id, '.xml')" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of
                                select="concat($outdir,  parent::compounddef/compoundname, '.xml')"
                             />
                        </xsl:otherwise>
                    </xsl:choose>

                </xsl:variable>
                <xsl:result-document doctype-public="-//QNX//Specialization Reference//EN"
                    doctype-system="http://www.qnx.com/dita/xml/1.2/reference.dtd" encoding="utf-8"
                    href="file:///{$outpath}" method="xml">
                    <xsl:comment>The content of this topic is automatically generated.</xsl:comment>
                    <xsl:element name="reference">
                        <xsl:attribute name="id" select="parent::compounddef/compoundname" />
                        <xsl:attribute name="xml:lang">
                            <xsl:text>en-us</xsl:text>
                        </xsl:attribute>
                        <xsl:call-template name="topic_title" />
                        <xsl:call-template name="shortdesc" />
                        <!--<xsl:call-template name="refbody" />-->
                        <xsl:element name="refbody">
                            <!--<xsl:element name="refsyn">
                                <xsl:element name="title">
                                    <xsl:text>Synopsis:</xsl:text>
                                </xsl:element>
                                <xsl:call-template name="verbatim" />
                            </xsl:element>
                            <xsl:element name="section">
                                <xsl:element name="title">
                                    <xsl:text>Data:</xsl:text>
                                </xsl:element>
                                <xsl:call-template name="defn_list" />
                            </xsl:element>-->
                            <xsl:element name="section">
                                <xsl:element name="title">
                                    <xsl:text>Library:</xsl:text>
                                </xsl:element>
                                <xsl:call-template name="library" />
                            </xsl:element>
                            <xsl:element name="section">
                                <xsl:element name="title">
                                    <xsl:text>Description:</xsl:text>
                                </xsl:element>
                                <xsl:apply-templates select="../detaileddescription/para" />
                            </xsl:element>
                        </xsl:element>
                    </xsl:element>
                </xsl:result-document>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template match="incdepgraph" />

    <xsl:template match="sectiondef">
        <xsl:choose>
            <!-- /////DEFINES\\\\\ -->
            <!--<xsl:when test=".[@kind='enum' or @kind='typedef']">
                <xsl:apply-templates />
            </xsl:when>-->
            <xsl:when
                test=".[@kind='user-defined' or @kind='define'] and ./memberdef[@kind='define']">
                <!-- Create parent section file name. -->
                <xsl:variable name="parentOutpath">
                    <xsl:value-of
                        select="concat($outdir,  parent::compounddef/compoundname, '_defines',
                        '_overview', '.xml')"
                     />
                </xsl:variable>
                <xsl:if test="not(preceding-sibling::node()/memberdef[@kind='define'])">
                    <xsl:result-document doctype-public="-//QNX//Specialization Concept//EN"
                        doctype-system="http://www.qnx.com/dita/xml/1.2/concept.dtd"
                        encoding="utf-8" href="file:///{$parentOutpath}" method="xml">
                        <xsl:comment>The content of this topic is automatically
                            generated.</xsl:comment>
                        <xsl:element name="concept">
                            <xsl:attribute name="id"
                                select="concat(parent::compounddef/compoundname,
                                '_defines', '_overview')" />
                            <xsl:attribute name="xml:lang">
                                <xsl:text>en-us</xsl:text>
                            </xsl:attribute>
                            <xsl:call-template name="sub_topic_title">
                                <xsl:with-param name="level">
                                    <xsl:text>defines</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_shortdesc">
                                <xsl:with-param name="level">
                                    <xsl:text>defines</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_body">
                                <xsl:with-param name="level">
                                    <xsl:text>defines</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                        </xsl:element>
                    </xsl:result-document>
                </xsl:if>
                <!-- Create a subsection file name under the parent, if necessary. -->
                <xsl:if test="header">
                    <xsl:variable name="group" select="translate(header, ' .', '')" />
                    <xsl:variable name="subParentOutpath"
                        select="concat($outdir,  parent::compounddef/compoundname, '_defines',
                            $group, '.xml')" />
                    <xsl:result-document doctype-public="-//QNX//Specialization Concept//EN"
                        doctype-system="http://www.qnx.com/dita/xml/1.2/concept.dtd"
                        encoding="utf-8" href="file:///{$subParentOutpath}" method="xml">
                        <xsl:comment>The content of this topic is automatically
                            generated.</xsl:comment>
                        <xsl:element name="concept">
                            <xsl:attribute name="id"
                                select="concat(parent::compounddef/compoundname,
                            '_defines', $group)" />
                            <xsl:attribute name="xml:lang">
                                <xsl:text>en-us</xsl:text>
                            </xsl:attribute>
                            <xsl:call-template name="sub_topic_title">
                                <xsl:with-param name="level">
                                    <xsl:text>definesLevel2</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_shortdesc">
                                <xsl:with-param name="level">
                                    <xsl:text>definesLevel2</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_body">
                                <xsl:with-param name="level">
                                    <xsl:text>definesLevel2</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                        </xsl:element>
                    </xsl:result-document>
                </xsl:if>
                <!-- Create file name(s) of topic(s). -->
                <xsl:variable name="outpath">
                    <xsl:value-of
                        select="concat($outdir,  parent::compounddef/compoundname, '_defines',
                        '.xml')"
                     />
                </xsl:variable>
                <xsl:result-document doctype-public="-//QNX//Specialization Reference//EN"
                    doctype-system="http://www.qnx.com/dita/xml/1.2/reference.dtd" encoding="utf-8"
                    href="file:///{$outpath}" method="xml">
                    <xsl:comment>The content of this topic is automatically generated.</xsl:comment>
                    <xsl:element name="reference">
                        <xsl:attribute name="id"
                            select="concat(parent::compounddef/compoundname,
                            '_defines')" />
                        <xsl:attribute name="xml:lang">
                            <xsl:text>en-us</xsl:text>
                        </xsl:attribute>
                        <xsl:call-template name="topic_title" />
                        <xsl:call-template name="shortdesc" />
                        <xsl:call-template name="refbody" />
                    </xsl:element>
                </xsl:result-document>
            </xsl:when>
            <!-- /////FUNCTIONS\\\\\ -->
            <xsl:when
                test=".[@kind='user-defined' or @kind='define' or @kind='func'] and
            ./memberdef[@kind='function']">
                <xsl:variable name="parentOutpath">
                    <xsl:value-of
                        select="concat($outdir,  parent::compounddef/compoundname, '_functions',
                        '_overview', '.xml')"
                     />
                </xsl:variable>
                <xsl:if test="not(preceding-sibling::node()/memberdef[@kind='function'])">
                    <xsl:result-document doctype-public="-//QNX//Specialization Concept//EN"
                        doctype-system="http://www.qnx.com/dita/xml/1.2/concept.dtd"
                        encoding="utf-8" href="file:///{$parentOutpath}" method="xml">
                        <xsl:comment>The content of this topic is automatically
                            generated.</xsl:comment>
                        <xsl:element name="concept">
                            <xsl:attribute name="id"
                                select="concat(parent::compounddef/compoundname,
                                '_functions', '_overview')" />
                            <xsl:attribute name="xml:lang">
                                <xsl:text>en-us</xsl:text>
                            </xsl:attribute>
                            <xsl:call-template name="sub_topic_title">
                                <xsl:with-param name="level">
                                    <xsl:text>functions</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_shortdesc">
                                <xsl:with-param name="level">
                                    <xsl:text>functions</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_body">
                                <xsl:with-param name="level">
                                    <xsl:text>functions</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                        </xsl:element>
                    </xsl:result-document>
                </xsl:if>
                <!-- Create a subsection file name under the parent, if necessary. -->
                <xsl:if test="header">
                    <xsl:variable name="group" select="translate(header, ' .', '')" />
                    <xsl:variable name="subParentOutpath"
                        select="concat($outdir,  parent::compounddef/compoundname, '_functions',
                            $group, '.xml')" />
                    <xsl:result-document doctype-public="-//QNX//Specialization Concept//EN"
                        doctype-system="http://www.qnx.com/dita/xml/1.2/concept.dtd"
                        encoding="utf-8" href="file:///{$subParentOutpath}" method="xml">
                        <xsl:comment>The content of this topic is automatically
                            generated.</xsl:comment>
                        <xsl:element name="concept">
                            <xsl:attribute name="id"
                                select="concat(parent::compounddef/compoundname,
                            '_functions', $group)" />
                            <xsl:attribute name="xml:lang">
                                <xsl:text>en-us</xsl:text>
                            </xsl:attribute>
                            <xsl:call-template name="sub_topic_title">
                                <xsl:with-param name="level">
                                    <xsl:text>functionsLevel2</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_shortdesc">
                                <xsl:with-param name="level">
                                    <xsl:text>functionsLevel2</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_body">
                                <xsl:with-param name="level">
                                    <xsl:text>functionsLevel2</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                        </xsl:element>
                    </xsl:result-document>
                </xsl:if>
                <xsl:apply-templates />
            </xsl:when>
            <!-- /////ENUMS\\\\\ -->
            <xsl:when test=".[@kind='enum'] and ./memberdef[@kind='enum']">
                <xsl:variable name="parentOutpath">
                    <xsl:value-of
                        select="concat($outdir,  parent::compounddef/compoundname, '_enums',
                        '_overview', '.xml')"
                     />
                </xsl:variable>
                <xsl:if test="not(preceding-sibling::node()/memberdef[@kind='enum'])">
                    <xsl:result-document doctype-public="-//QNX//Specialization Concept//EN"
                        doctype-system="http://www.qnx.com/dita/xml/1.2/concept.dtd"
                        encoding="utf-8" href="file:///{$parentOutpath}" method="xml">
                        <xsl:comment>The content of this topic is automatically
                            generated.</xsl:comment>
                        <xsl:element name="concept">
                            <xsl:attribute name="id"
                                select="concat(parent::compounddef/compoundname,
                            '_functions', '_overview')" />
                            <xsl:attribute name="xml:lang">
                                <xsl:text>en-us</xsl:text>
                            </xsl:attribute>
                            <xsl:call-template name="sub_topic_title">
                                <xsl:with-param name="level">
                                    <xsl:text>enums</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_shortdesc">
                                <xsl:with-param name="level">
                                    <xsl:text>enums</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_body">
                                <xsl:with-param name="level">
                                    <xsl:text>enums</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                        </xsl:element>
                    </xsl:result-document>
                </xsl:if>
                <!-- Create a subsection file name under the parent, if necessary. -->
                <xsl:if test="header">
                    <xsl:variable name="group" select="translate(header, ' .', '')" />
                    <xsl:variable name="subParentOutpath"
                        select="concat($outdir,  parent::compounddef/compoundname, '_enums',
                            $group, '.xml')" />
                    <xsl:result-document doctype-public="-//QNX//Specialization Concept//EN"
                        doctype-system="http://www.qnx.com/dita/xml/1.2/concept.dtd"
                        encoding="utf-8" href="file:///{$subParentOutpath}" method="xml">
                        <xsl:comment>The content of this topic is automatically
                            generated.</xsl:comment>
                        <xsl:element name="concept">
                            <xsl:attribute name="id"
                                select="concat(parent::compounddef/compoundname,
                            '_enums', $group)" />
                            <xsl:attribute name="xml:lang">
                                <xsl:text>en-us</xsl:text>
                            </xsl:attribute>
                            <xsl:call-template name="sub_topic_title">
                                <xsl:with-param name="level">
                                    <xsl:text>enumsLevel2</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_shortdesc">
                                <xsl:with-param name="level">
                                    <xsl:text>enumsLevel2</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_body">
                                <xsl:with-param name="level">
                                    <xsl:text>enumsLevel2</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                        </xsl:element>
                    </xsl:result-document>
                </xsl:if>
                <xsl:apply-templates />
            </xsl:when>
            <!-- /////TYPEDEFS\\\\\ -->
            <xsl:when test=".[@kind='typedef'] and ./memberdef[@kind='typedef']">
                <xsl:variable name="parentOutpath">
                    <xsl:value-of
                        select="concat($outdir,  parent::compounddef/compoundname, '_typedefs',
                        '_overview', '.xml')"
                     />
                </xsl:variable>
                <xsl:if test="not(preceding-sibling::node()/memberdef[@kind='typedef'])">
                    <xsl:result-document doctype-public="-//QNX//Specialization Concept//EN"
                        doctype-system="http://www.qnx.com/dita/xml/1.2/concept.dtd"
                        encoding="utf-8" href="file:///{$parentOutpath}" method="xml">
                        <xsl:comment>The content of this topic is automatically
                            generated.</xsl:comment>
                        <xsl:element name="concept">
                            <xsl:attribute name="id"
                                select="concat(parent::compounddef/compoundname, '_typedefs', '_overview')" />
                            <xsl:attribute name="xml:lang">
                                <xsl:text>en-us</xsl:text>
                            </xsl:attribute>
                            <xsl:call-template name="sub_topic_title">
                                <xsl:with-param name="level">
                                    <xsl:text>typedefs</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_shortdesc">
                                <xsl:with-param name="level">
                                    <xsl:text>typedefs</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_body">
                                <xsl:with-param name="level">
                                    <xsl:text>typedefs</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                        </xsl:element>
                    </xsl:result-document>
                </xsl:if>
                <!-- Create a subsection file name under the parent, if necessary. -->
                <xsl:if test="header">
                    <xsl:variable name="group" select="translate(header, ' .', '')" />
                    <xsl:variable name="subParentOutpath"
                        select="concat($outdir,  parent::compounddef/compoundname, '_typedefs',
                            $group, '.xml')" />
                    <xsl:result-document doctype-public="-//QNX//Specialization Concept//EN"
                        doctype-system="http://www.qnx.com/dita/xml/1.2/concept.dtd"
                        encoding="utf-8" href="file:///{$subParentOutpath}" method="xml">
                        <xsl:comment>The content of this topic is automatically
                            generated.</xsl:comment>
                        <xsl:element name="concept">
                            <xsl:attribute name="id"
                                select="concat(parent::compounddef/compoundname,
                            '_typedefs', $group)" />
                            <xsl:attribute name="xml:lang">
                                <xsl:text>en-us</xsl:text>
                            </xsl:attribute>
                            <xsl:call-template name="sub_topic_title">
                                <xsl:with-param name="level">
                                    <xsl:text>typedefsLevel2</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_shortdesc">
                                <xsl:with-param name="level">
                                    <xsl:text>typedefsLevel2</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                            <xsl:call-template name="sub_body">
                                <xsl:with-param name="level">
                                    <xsl:text>typedefsLevel2</xsl:text>
                                </xsl:with-param>
                            </xsl:call-template>
                        </xsl:element>
                    </xsl:result-document>
                </xsl:if>
                <xsl:apply-templates />
            </xsl:when>
            <!-- /////STRUCTS\\\\\ -->
            <xsl:when test="..[@kind='struct'] and @kind='public-attrib'">
                <xsl:variable name="outpath">
                    <xsl:choose>
                        <xsl:when test="contains(..[@id], struct)">
                            <xsl:value-of select="concat($outdir,  ../@id, '.xml')" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of
                                select="concat($outdir,  ../compoundname, '_', 'struct',
                                memberdef[1]/name, '.xml')"
                             />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:result-document doctype-public="-//QNX//Specialization Reference//EN"
                    doctype-system="http://www.qnx.com/dita/xml/1.2/reference.dtd" encoding="utf-8"
                    href="file:///{$outpath}" method="xml">
                    <xsl:call-template name="reference" />
                </xsl:result-document>
            </xsl:when>
            <xsl:when test="..[@kind='struct'] and @kind='public-func'">
                <xsl:variable name="outpath">
                    <xsl:choose>
                        <xsl:when test="contains(..[@id], struct)">
                            <xsl:value-of select="concat($outdir,  ../@id, '_func', '.xml')" />
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of
                                select="concat($outdir,  ../compoundname, '_', 'struct',
                                memberdef[1]/name, '.xml')"
                             />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:result-document doctype-public="-//QNX//Specialization Reference//EN"
                    doctype-system="http://www.qnx.com/dita/xml/1.2/reference.dtd" encoding="utf-8"
                    href="file:///{$outpath}" method="xml">
                    <xsl:call-template name="reference" />
                </xsl:result-document>
            </xsl:when>
            <xsl:otherwise />
        </xsl:choose>
    </xsl:template>

    <!-- 
        Creates output file(s) for structure reference information.
    -->
    <!--<xsl:template match="sectiondef">
        <xsl:choose>
            <xsl:when test="../../compounddef[@kind='struct']">
                <xsl:variable name="outpath">
                    <xsl:value-of
                        select="concat($outdir,  ../compoundname, '_', 'struct', '.xml')" />
                </xsl:variable>
                <xsl:result-document href="file:///{$outpath}" method="xml" encoding="utf-8"
                    doctype-public="-//QNX//Specialization Reference//EN"
                    doctype-system="http://www.qnx.com/dita/xml/1.2/reference.dtd">
                    <xsl:call-template name="reference" />
                </xsl:result-document>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="memberdef" />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>-->

    <!-- 
        Creates output files for API components.    
    -->
    <xsl:template match="memberdef">
        <xsl:variable name="funcname" select="name" />
        <xsl:variable name="compoundid" select="../../../compounddef/@id" />
        <xsl:choose>
            <!-- /////ANONYMOUS ENUMS\\\\\ -->
            <xsl:when test="contains(name, '@')">
                <xsl:choose>
                    <!-- Use Doxygen @section value for name of anonymous enum. -->
                    <xsl:when test="detaileddescription/sect1/title">
                        <xsl:variable name="outpath">
                            <xsl:value-of
                                select="concat($outdir, detaileddescription/sect1/@id, '.xml')" />
                        </xsl:variable>
                        <xsl:result-document doctype-public="-//QNX//Specialization Reference//EN"
                            doctype-system="http://www.qnx.com/dita/xml/1.2/reference.dtd"
                            encoding="utf-8" href="file:///{$outpath}" method="xml">
                            <xsl:call-template name="reference" />
                        </xsl:result-document>
                    </xsl:when>
                    <!-- Handle anonymous enums that are part of a group. -->
                    <xsl:when test="contains(@id, 'group')">
                        <!-- Open the associated doxyXML group file and get the value of the 
                             detaileddescription/sect1/@id attibute to create the file name. -->
                        <xsl:variable name="outpath">
                            <xsl:value-of
                                select="concat($outdir, doc(concat($srcdir, tokenize(@id, '_[0-9]')[1], '.xml'))/doxygen/compounddef/detaileddescription/sect1/@id, '.xml')"
                             />
                        </xsl:variable>
                        <xsl:result-document doctype-public="-//QNX//Specialization Reference//EN"
                            doctype-system="http://www.qnx.com/dita/xml/1.2/reference.dtd"
                            encoding="utf-8" href="file:///{$outpath}" method="xml">
                            <xsl:call-template name="reference" />
                        </xsl:result-document>
                    </xsl:when>
                    <!-- Define enum as 'anonymous', numbered sequentially. -->
                    <xsl:otherwise>
                        <xsl:variable name="outpath">
                            <xsl:value-of
                                select="concat($outdir,  substring-before(@id, '_'), '_',
                                'anonymous_enum', '_', name, '.xml')"
                             />
                        </xsl:variable>
                        <xsl:result-document doctype-public="-//QNX//Specialization Reference//EN"
                            doctype-system="http://www.qnx.com/dita/xml/1.2/reference.dtd"
                            encoding="utf-8" href="file:///{$outpath}" method="xml">
                            <xsl:call-template name="reference" />
                        </xsl:result-document>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <!-- /////FUNCTIONS\\\\\ -->
            <xsl:when test="@kind = 'function'">
                <!-- Count overloaded functions. -->
                <xsl:variable name="overloaded"
                    select="count(doc(concat($srcdir, 'index.xml'))/doxygenindex/compound[@refid = $compoundid]/member/name[child::text() = $funcname])" />
                <xsl:choose>
                    <!-- Create unique name for overloaded functions. -->
                    <xsl:when test="$overloaded &gt; 1">
                        <xsl:variable name="outpath">
                            <xsl:value-of select="concat($outdir,  name, '_', position(), '.xml')"
                             />
                        </xsl:variable>
                        <xsl:result-document doctype-public="-//QNX//Specialization Reference//EN"
                            doctype-system="http://www.qnx.com/dita/xml/1.2/reference.dtd"
                            encoding="utf-8" href="file:///{$outpath}" method="xml">
                            <xsl:call-template name="reference" />
                        </xsl:result-document>
                    </xsl:when>
                    <xsl:when test="contains(definition, '__SRCVERSION')" />
                    <xsl:otherwise>
                        <xsl:variable name="outpath">
                            <xsl:value-of select="concat($outdir,  name, '.xml')" />
                        </xsl:variable>
                        <xsl:result-document doctype-public="-//QNX//Specialization Reference//EN"
                            doctype-system="http://www.qnx.com/dita/xml/1.2/reference.dtd"
                            encoding="utf-8" href="file:///{$outpath}" method="xml">
                            <xsl:call-template name="reference" />
                        </xsl:result-document>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="definition = '__SRCVERSION'" />
            <!-- /////ALL OTHER API COMPONENTS\\\\\ -->
            <xsl:otherwise>
                <xsl:choose>
                    <!-- Prevent transformation from trying to create multiple
                         files of the same name for SC_TYPEINFO in Scoreloop
                         header files. -->
                    <xsl:when test="name = 'SC_TYPEINFO'">
                        <!-- Do nothing. --> </xsl:when>
                    <xsl:when test="contains(definition, '__SRCVERSION')" />
                    <xsl:otherwise>
                        <xsl:variable name="outpath">
                            <xsl:value-of select="concat($outdir,  name, '.xml')" />
                        </xsl:variable>
                        <xsl:result-document doctype-public="-//QNX//Specialization Reference//EN"
                            doctype-system="http://www.qnx.com/dita/xml/1.2/reference.dtd"
                            encoding="utf-8" href="file:///{$outpath}" method="xml">
                            <xsl:call-template name="reference" />
                        </xsl:result-document>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
        <!--<xsl:apply-templates select="memberdef" />-->
    </xsl:template>

    <!-- 
        Builds DITA reference topic structure.
    -->
    <xsl:template name="reference">
        <xsl:element name="reference">
            <xsl:choose>
                <xsl:when test="..[@kind='struct']">
                    <xsl:attribute name="id">
                        <xsl:value-of select="../compoundname" />
                    </xsl:attribute>
                    <xsl:attribute name="xml:lang">
                        <xsl:text>en-us</xsl:text>
                    </xsl:attribute>
                    <xsl:call-template name="topic_title" />
                    <xsl:call-template name="shortdesc" />
                    <xsl:call-template name="refbody" />
                </xsl:when>
                <xsl:when test=".[@kind='define' or @kind='user=defined']">
                    <xsl:attribute name="id" select="parent::compounddef/compoundname" />
                    <xsl:attribute name="xml:lang">
                        <xsl:text>en-us</xsl:text>
                    </xsl:attribute>
                    <xsl:call-template name="topic_title" />
                    <xsl:call-template name="shortdesc" />
                    <xsl:call-template name="refbody" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:attribute name="id">
                        <xsl:choose>
                            <xsl:when test="contains(name, '@')">
                                <xsl:value-of select="concat('at', '_', substring-after(name, '@'))"
                                 />
                            </xsl:when>
                            <xsl:when test=".[@kind='function']">
                                <xsl:value-of select="@id" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="name" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:attribute>
                    <xsl:attribute name="xml:lang">
                        <xsl:text>en-us</xsl:text>
                    </xsl:attribute>
                    <xsl:call-template name="topic_title" />
                    <xsl:call-template name="shortdesc" />
                    <xsl:call-template name="refbody" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:element>
    </xsl:template>

    <!-- 
        Creates the topic's title element.
    -->
    <xsl:template name="topic_title">
        <xsl:element name="title">
            <xsl:choose>
                <xsl:when test=".[@kind='define' or @kind='user-defined']">
                    <xsl:text>Definitions in </xsl:text>
                    <xsl:element name="apiname">
                        <xsl:value-of select="parent::compounddef/compoundname" />
                    </xsl:element>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:element name="apiname">
                        <xsl:choose>
                            <xsl:when test="@kind='function'">
                                <xsl:value-of select="name" />
                                <xsl:text>()</xsl:text>
                            </xsl:when>
                            <!-- Handle naming for anonymous enums. -->
                            <xsl:when test="@kind='enum' and contains(name, '@')">
                                <xsl:choose>
                                    <!-- Take value of section's title element (Doxy: @section) 
                                         and assign it as the name for an anonymous enum. -->
                                    <xsl:when test="detaileddescription/sect1/title">
                                        <xsl:value-of select="detaileddescription/sect1/title" />
                                    </xsl:when>
                                    <!-- Enums in groups. -->
                                    <xsl:when test="contains(@id, 'group')">
                                        <xsl:value-of
                                            select="doc(concat($srcdir, tokenize(@id, '_1')[1], '.xml'))/doxygen/compounddef/detaileddescription/sect1/title"
                                         />
                                    </xsl:when>
                                    <!-- If there is no @section tag in the Doxygen comments,
                                         the enum remains anonymous. -->
                                    <xsl:otherwise>
                                        <xsl:value-of
                                            select="concat(substring-before(@id, '_'), '_',
                                            'anonymous_enum')"
                                         />
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:when>
                            <xsl:when test="@kind='enum' and not(contains(name, '@'))">
                                <xsl:value-of select="name" />
                            </xsl:when>
                            <xsl:when test="@kind='typedef'">
                                <xsl:value-of select="name" />
                            </xsl:when>
                            <xsl:when test="@kind='define'">
                                <xsl:value-of select="name" />
                            </xsl:when>
                            <xsl:when test="..[@kind='struct']">
                                <xsl:value-of select="../compoundname" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:text>UNDETERMINED</xsl:text>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:element>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:element>
    </xsl:template>

    <!-- 
        Create parent topic title.
    -->
    <xsl:template name="sub_topic_title">
        <xsl:param name="level" />
        <xsl:element name="title">
            <xsl:choose>
                <xsl:when test="$level='defines'">
                    <xsl:text>Definitions in </xsl:text>
                    <xsl:element name="apiname">
                        <xsl:value-of select="parent::compounddef/compoundname" />
                    </xsl:element>
                </xsl:when>
                <xsl:when test="$level='definesLevel2'">
                    <xsl:value-of select="header" />
                </xsl:when>
                <xsl:when test="$level='functions'">
                    <xsl:text>Functions in </xsl:text>
                    <xsl:element name="apiname">
                        <xsl:value-of select="parent::compounddef/compoundname" />
                    </xsl:element>
                </xsl:when>
                <xsl:when test="$level='functionsLevel2'">
                    <xsl:value-of select="header" />
                </xsl:when>
                <xsl:when test="$level='enums'">
                    <xsl:text>Enumerations in </xsl:text>
                    <xsl:element name="apiname">
                        <xsl:value-of select="parent::compounddef/compoundname" />
                    </xsl:element>
                </xsl:when>
                <xsl:when test="$level='enumsLevel2'">
                    <xsl:value-of select="header" />
                </xsl:when>
                <xsl:when test="$level='typedefs'">
                    <xsl:text>Typedefs in </xsl:text>
                    <xsl:element name="apiname">
                        <xsl:value-of select="parent::compounddef/compoundname" />
                    </xsl:element>
                </xsl:when>
                <xsl:when test="$level='typdefsLevel2'">
                    <xsl:value-of select="header" />
                </xsl:when>
                <xsl:otherwise />
            </xsl:choose>
        </xsl:element>
    </xsl:template>

    <!-- 
        Create parent short description.
    -->
    <xsl:template name="sub_shortdesc">
        <xsl:param name="level" />
        <xsl:element name="shortdesc">
            <!--<xsl:choose>
                <xsl:when test="$level='defines'">
                    <xsl:text>This section describes the macro definitions in the </xsl:text>
                    <xsl:element name="apiname">
                        <xsl:value-of select="parent::compounddef/compoundname" />
                    </xsl:element>
                    <xsl:text> header file.</xsl:text>
                </xsl:when>
                <xsl:when test="$level='definesLevel2'">
                    <xsl:value-of select="description/para[1]" />
                </xsl:when>
                <xsl:when test="$level='functions'">
                    <xsl:text>This section describes the functions in the </xsl:text>
                    <xsl:element name="apiname">
                        <xsl:value-of select="parent::compounddef/compoundname" />
                    </xsl:element>
                    <xsl:text> header file.</xsl:text>
                </xsl:when>
                <xsl:when test="$level='functionsLevel2'">
                    <xsl:value-of select="description/para[1]" />
                </xsl:when>
                <xsl:when test="$level='enums'">
                    <xsl:text>This section describes the enumerations in the </xsl:text>
                    <xsl:element name="apiname">
                        <xsl:value-of select="parent::compounddef/compoundname" />
                    </xsl:element>
                    <xsl:text> header file.</xsl:text>
                </xsl:when>
                <xsl:when test="$level='enumsLevel2'">
                    <xsl:value-of select="description/para[1]" />
                </xsl:when>
                <xsl:when test="$level='enums'">
                    <xsl:text>This section describes the typedefs in the </xsl:text>
                    <xsl:element name="apiname">
                        <xsl:value-of select="parent::compounddef/compoundname" />
                    </xsl:element>
                    <xsl:text> header file.</xsl:text>
                </xsl:when>
                <xsl:when test="$level='typedefsLevel2'">
                    <xsl:value-of select="description/para[1]" />
                </xsl:when>
                <xsl:otherwise />
            </xsl:choose>-->
        </xsl:element>
    </xsl:template>

    <!-- 
        Create parent conbody.
    -->
    <xsl:template name="sub_body">
        <xsl:param name="level" />
        <xsl:choose>
            <xsl:when test="$level='defines'">
                <xsl:element name="conbody" />
            </xsl:when>
            <xsl:when test="$level='definesLevel2'">
                <xsl:element name="conbody">
                    <xsl:apply-templates select="description" />
                </xsl:element>
            </xsl:when>
            <xsl:otherwise />
        </xsl:choose>
    </xsl:template>

    <!-- 
        Creates the topic's shortdesc element. 
    -->
    <xsl:template name="shortdesc">
        <xsl:choose>
            <xsl:when test="..[@kind='struct']">
                <xsl:element name="shortdesc">
                    <xsl:element name="i">
                        <xsl:apply-templates select="../briefdescription/para" />
                    </xsl:element>
                </xsl:element>
            </xsl:when>
            <xsl:when test=".[@kind='define' or @kind='user-defined']">
                <xsl:element name="shortdesc">
                    <xsl:element name="i">
                        <xsl:text>Preprocessor macro definitions for the </xsl:text>
                        <xsl:value-of select="parent::compounddef/compoundname" />
                        <xsl:text> header file in the </xsl:text>
                        <xsl:value-of select="$apiLib" />
                        <xsl:text> library.</xsl:text>
                    </xsl:element>
                </xsl:element>
            </xsl:when>
            <xsl:otherwise>
                <xsl:element name="shortdesc">
                    <xsl:element name="i">
                        <xsl:apply-templates select="briefdescription/para" />
                    </xsl:element>
                </xsl:element>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:call-template name="create_prolog" />
    </xsl:template>
    
    <xsl:template name="create_prolog">
        <xsl:element name="prolog">
            <xsl:element name="metadata">
                <xsl:element name="othermeta">
                    <xsl:attribute name="content">doxygen</xsl:attribute>
                    <xsl:attribute name="name">source</xsl:attribute>
                </xsl:element>
            </xsl:element>
        </xsl:element>   
    </xsl:template>

    <!-- 
        Creates the topic's refbody element.
    -->
    <xsl:template name="refbody">
        <xsl:element name="refbody">
            <xsl:choose>
                <xsl:when test="@kind='define' or @kind='user-defined'">
                    <!--<xsl:call-template name="sectionDefHeader" />-->
                    <xsl:call-template name="section_driver" />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="section_driver" />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:element>
    </xsl:template>

    <!-- 
        Creates the section child elements of refbody.
    -->
    <xsl:template name="section_driver">
        <xsl:choose>
            <xsl:when test="@kind='define' or @kind='user-defined'">
                <xsl:element name="refsyn">
                    <xsl:element name="title">
                        <xsl:text>Definitions:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="verbatim">
                        <xsl:with-param name="apiType">
                            <xsl:text>define</xsl:text>
                        </xsl:with-param>
                    </xsl:call-template>
                </xsl:element>
                <xsl:element name="section">
                    <xsl:element name="title">
                        <xsl:text>Library:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="library" />
                </xsl:element>
            </xsl:when>
            <xsl:when test="@kind='typedef'">
                <xsl:element name="refsyn">
                    <xsl:element name="title">
                        <xsl:text>Synopsis:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="verbatim">
                        <xsl:with-param name="apiType" select="@kind" />
                    </xsl:call-template>
                </xsl:element>
                <xsl:choose>
                    <xsl:when
                        test="detaileddescription/para[1]/parameterlist or
                        detaileddescription/para[1]/simplesect">
                        <xsl:element name="section">
                            <xsl:element name="title">
                                <xsl:text>Arguments:</xsl:text>
                            </xsl:element>
                            <xsl:call-template name="defn_list" />
                        </xsl:element>
                    </xsl:when>
                    <xsl:otherwise>
                        <!-- Do nothing. -->
                        <!--<xsl:apply-templates
                            select="(detaileddescription/para) except (detaileddescription/para[child::parameterlist] |
                            detaileddescription/para[child::simplesect])"
                        />-->
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:if test="detaileddescription/para/simplesect[@kind='since']">
                    <xsl:element name="section">
                        <xsl:attribute name="product">NDK</xsl:attribute>
                        <xsl:element name="title">
                            <xsl:text>Since:</xsl:text>
                        </xsl:element>
                        <xsl:call-template name="since" />
                    </xsl:element>
                </xsl:if>
                <xsl:element name="section">
                    <xsl:element name="title">
                        <xsl:text>Library:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="library" />
                </xsl:element>
                <xsl:element name="section">
                    <xsl:element name="title">
                        <xsl:text>Description:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="description" />
                </xsl:element>
            </xsl:when>
            <xsl:when test="@kind='enum'">
                <xsl:element name="refsyn">
                    <xsl:element name="title">
                        <xsl:text>Synopsis:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="verbatim">
                        <xsl:with-param name="apiType" select="@kind" />
                    </xsl:call-template>
                </xsl:element>
                <xsl:if test="detaileddescription/para/simplesect[@kind='since'] | detaileddescription/sect1/para/simplesect[@kind='since']">
                    <xsl:element name="section">
                        <xsl:attribute name="product">NDK</xsl:attribute>
                        <xsl:element name="title">
                            <xsl:text>Since:</xsl:text>
                        </xsl:element>
                        <xsl:call-template name="since" />
                    </xsl:element>
                </xsl:if>
                <xsl:element name="section">
                    <xsl:element name="title">
                        <xsl:text>Data:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="defn_list" />
                </xsl:element>
                <xsl:element name="section">
                    <xsl:element name="title">
                        <xsl:text>Library:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="library" />
                </xsl:element>
                <xsl:element name="section">
                    <xsl:element name="title">
                        <xsl:text>Description:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="description" />
                </xsl:element>
            </xsl:when>
            <xsl:when test="@kind='function'">
                <xsl:element name="refsyn">
                    <xsl:element name="title">
                        <xsl:text>Synopsis:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="verbatim">
                        <xsl:with-param name="apiType" select="@kind" />
                    </xsl:call-template>
                </xsl:element>
                <xsl:if test="detaileddescription/para/simplesect[@kind='since']">
                    <xsl:element name="section">
                        <xsl:attribute name="product">NDK</xsl:attribute>
                        <xsl:element name="title">
                            <xsl:text>Since:</xsl:text>
                        </xsl:element>
                        <xsl:call-template name="since" />
                    </xsl:element>
                </xsl:if>
                <xsl:element name="section">
                    <xsl:element name="title">
                        <xsl:text>Arguments:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="defn_list" />
                </xsl:element>
                <xsl:element name="section">
                    <xsl:element name="title">
                        <xsl:text>Library:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="library" />
                </xsl:element>
                <xsl:element name="section">
                    <xsl:element name="title">
                        <xsl:text>Description:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="description" />
                </xsl:element>
                <xsl:element name="section">
                    <xsl:element name="title">
                        <xsl:text>Returns:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="returns" />
                </xsl:element>
            </xsl:when>
            <xsl:when test="..[@kind='struct']">
                <xsl:element name="refsyn">
                    <xsl:element name="title">
                        <xsl:text>Synopsis:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="verbatim" />
                </xsl:element>
                <xsl:choose>
                    <xsl:when test="../detaileddescription/para/simplesect[@kind='since']">
                        <xsl:element name="section">
                            <xsl:attribute name="product">NDK</xsl:attribute>
                            <xsl:element name="title">
                                <xsl:text>Since:</xsl:text>
                            </xsl:element>
                            <xsl:element name="p">
                                <xsl:value-of select="../detaileddescription/para/simplesect[@kind='since']/para" />
                            </xsl:element>
                        </xsl:element>
                    </xsl:when>
                    <xsl:when test="detaileddescription/para/simplesect[@kind='since']">
                        <xsl:element name="section">
                            <xsl:attribute name="product">NDK</xsl:attribute>
                            <xsl:element name="title">
                                <xsl:text>Since:</xsl:text>
                            </xsl:element>
                            <xsl:element name="p">
                                <xsl:value-of select="detaileddescription/para/simplesect[@kind='since']/para" />
                            </xsl:element>
                        </xsl:element>
                    </xsl:when>
                </xsl:choose>
                <!--<xsl:if test="../detaileddescription/para/simplesect[@kind='since']">
                    <xsl:element name="section">
                        <xsl:element name="title">
                            <xsl:text>Since:</xsl:text>
                        </xsl:element>
                        <xsl:element name="p">
                            <xsl:value-of select="../detaileddescription/para/simplesect[@kind='since']/para" />
                        </xsl:element>
                    </xsl:element>
                </xsl:if>-->
                <xsl:element name="section">
                    <xsl:element name="title">
                        <xsl:text>Data:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="defn_list" />
                </xsl:element>
                <xsl:element name="section">
                    <xsl:element name="title">
                        <xsl:text>Library:</xsl:text>
                    </xsl:element>
                    <xsl:call-template name="library" />
                </xsl:element>
                <xsl:element name="section">
                    <xsl:element name="title">
                        <xsl:text>Description:</xsl:text>
                    </xsl:element>
                    <xsl:apply-templates select="../detaileddescription/para" />
                </xsl:element>
            </xsl:when>
            <xsl:otherwise />
        </xsl:choose>
    </xsl:template>

    <!-- 
        Definition list template
    -->
    <xsl:template name="defn_list">
        <xsl:choose>
            <xsl:when test="@kind='enum'">
                <xsl:for-each select="enumvalue">
                    <xsl:element name="dl">
                        <xsl:element name="dlentry">
                            <xsl:attribute name="id" select="@id" />
                            <xsl:element name="dt">
                                <xsl:element name="varname">
                                    <xsl:value-of select="name" />
                                </xsl:element>
                            </xsl:element>
                            <xsl:element name="dd">
                                <xsl:value-of select="briefdescription/para" />
                            </xsl:element>
                            <xsl:if test="detaileddescription/para/child::text()">
                                <xsl:element name="dd">
                                    <!--<xsl:value-of select="detaileddescription/para"/>-->
                                    <xsl:apply-templates select="detaileddescription/para" />
                                </xsl:element>
                            </xsl:if>
                        </xsl:element>
                    </xsl:element>
                </xsl:for-each>
            </xsl:when>
            <xsl:when test="../@kind='struct'">
                <xsl:for-each select="../sectiondef/memberdef">
                    <xsl:element name="dl">
                        <xsl:element name="dlentry">
                            <xsl:element name="dt">
                                <xsl:element name="varname">
                                    <xsl:value-of select="type" />
                                    <xsl:text> </xsl:text>
                                    <xsl:value-of select="name" />
                                    <xsl:value-of select="argsstring" />
                                </xsl:element>
                            </xsl:element>
                            <xsl:element name="dd">
                                <xsl:value-of select="briefdescription/para" />
                            </xsl:element>
                            <xsl:if test="detaileddescription/para/child::text()">
                                <xsl:element name="dd">
                                    <xsl:call-template name="description" />
                                    <xsl:if test="detaileddescription/para/simplesect[@kind='since']">
                                        <xsl:element name="p">
                                            <xsl:attribute name="product">NDK</xsl:attribute>
                                            <xsl:element name="b">
                                                <xsl:text>Since: </xsl:text>
                                            </xsl:element>
                                            <xsl:value-of select="detaileddescription/para/simplesect[@kind='since']/para" />
                                        </xsl:element>
                                    </xsl:if>
                                    </xsl:element>
                            </xsl:if>
                        </xsl:element>
                        </xsl:element>
                </xsl:for-each>
            </xsl:when>
            <xsl:otherwise>
                <xsl:for-each
                    select="detaileddescription/para/parameterlist[@kind='param']/parameteritem">
                    <xsl:element name="dl">
                        <xsl:element name="dlentry">
                            <xsl:element name="dt">
                                <xsl:element name="varname">
                                    <xsl:value-of select="parameternamelist/parametername" />
                                </xsl:element>
                            </xsl:element>
                            <xsl:element name="dd">
                                <!--<xsl:value-of select="parameterdescription/para"/>-->
                                <xsl:apply-templates select="parameterdescription" />
                            </xsl:element>
                        </xsl:element>
                    </xsl:element>
                </xsl:for-each>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template match="parameterlist[@kind='param']">
        <xsl:for-each select="parameteritem">
            <xsl:element name="dl">
                <xsl:element name="dlentry">
                    <xsl:element name="dt">
                        <xsl:element name="varname">
                            <xsl:value-of select="parameternamelist/parametername" />
                        </xsl:element>
                    </xsl:element>
                    <xsl:element name="dd">
                        <!--<xsl:value-of select="parameterdescription/para"/>-->
                        <xsl:apply-templates select="parameterdescription" />
                    </xsl:element>
                </xsl:element>
            </xsl:element>
        </xsl:for-each>
    </xsl:template>

    <xsl:template match="parameterdescription">
        <xsl:apply-templates />
    </xsl:template>

    <!-- 
        Creates the library section element.
    -->
    <xsl:template name="library">
        <xsl:choose>
            <xsl:when test="..[@kind='struct']">
                <xsl:element name="codeph">
                    <xsl:value-of select="$apiLib" />
                </xsl:element>
            </xsl:when>
            <xsl:when test="memberdef[@kind='define']">
                <xsl:element name="codeph">
                    <xsl:value-of select="$apiLib" />
                </xsl:element>
            </xsl:when>
            <xsl:otherwise>
                <xsl:element name="codeph">
                    <xsl:value-of select="$apiLib" />
                </xsl:element>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- 
        Creates section to output sectionDef header description. 
    -->
    <xsl:template name="sectionDefHeader">
        <xsl:element name="section">
            <xsl:element name="title">
                <xsl:value-of select="header" />
            </xsl:element>
            <xsl:apply-templates select="description" />
        </xsl:element>
    </xsl:template>

    <!-- 
        Processes the content for the sectionDef's description.
    -->
    <xsl:template match="description">
        <xsl:apply-templates />
    </xsl:template>

    <!-- 
        One of two templates that processes the content for the topic's 
        detailed description. 
        
        Processes para children of the Doxygen detaileddescription element 
        except those that are also children of the parameterlist element.
    -->
    <xsl:template name="description">
        <xsl:choose>
            <xsl:when
                test="detaileddescription/para[1]/parameterlist or
                detaileddescription/para[1]/simplesect">
                <xsl:apply-templates select="detaileddescription/para" mode="paramlist" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates
                    select="(detaileddescription/para) except (detaileddescription/para[child::parameterlist] |
                    detaileddescription/para[child::simplesect])"
                 />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!--
        Creates the topic's returns element.
        (From Tim Howie).
    -->
    <xsl:template name="returns">
        <xsl:apply-templates select="detaileddescription//simplesect[@kind='return']/para" />
        <xsl:if test="detaileddescription//simplesect[@kind='see']">
            <!--<xsl:element name="p">
                <xsl:element name="b">
                    <xsl:text>See also:</xsl:text>
                </xsl:element>
            </xsl:element>
            <xsl:apply-templates select="detaileddescription//simplesect[@kind='see']/para" />-->
            <xsl:element name="dl">
                <xsl:element name="dlentry">
                    <xsl:element name="dt">
                        <xsl:text>See also: </xsl:text>
                    </xsl:element>
                    <xsl:element name="dd">
                        <xsl:apply-templates select="detaileddescription//simplesect[@kind='see']/para" />
                    </xsl:element>
                </xsl:element>
            </xsl:element>
        </xsl:if>
        
        <xsl:for-each select="detaileddescription/para/parameterlist[@kind='retval']/parameteritem">
            <xsl:element name="dl">
                <xsl:element name="dlentry">
                    <xsl:element name="dt">
                        <xsl:element name="varname">
                            <xsl:value-of select="parameternamelist/parametername" />
                        </xsl:element>
                    </xsl:element>
                    <xsl:element name="dd">
                        <!--<xsl:value-of select="parameterdescription/para"/>-->
                        <xsl:apply-templates select="parameterdescription" />
                    </xsl:element>
                </xsl:element>
            </xsl:element>
        </xsl:for-each>
    </xsl:template>
    
    <!-- select="if (ancestor::memberdef/detaileddescription/sect1) 
                 then concat(concat(//enumvalue[@id = $componentid]/parent::memberdef/detaileddescription/sect1/@id, '.xml'), '#', 'at_', substring-after(//enumvalue[@id = $componentid]/parent::memberdef/name, '@'), '/', @refid) 
                 else concat(concat(distinct-values(doc(concat($srcdir, 'index.xml'))/doxygenindex/compound/member[@kind='enum'][following-sibling::member[name=$localapiname][preceding-sibling::member[@kind='enum']]][last()]/name), '.xml'), '#', concat(concat(distinct-values(doc(concat($srcdir, 'index.xml'))/doxygenindex/compound/member[@kind='enum'][following-sibling::member[name=$localapiname][preceding-sibling::member[@kind='enum']]][last()]/name), '__'), @refid))" /> -->
    
    <!-- Creates the topic's Since section.  -->
    <xsl:template name="since">
        <xsl:apply-templates select="detaileddescription//simplesect[@kind='since']/para" />       
    </xsl:template>

    <!-- 
        Creates content for the topics shortdesc element.
    -->
    <xsl:template match="briefdescription/para">
        <xsl:apply-templates />
    </xsl:template>

    <!-- 
        Processes the content for the topic's detailed description. Don't process
        'todo' items.
    -->
    <xsl:template match="detaileddescription/para">
        <xsl:choose>
            <xsl:when test="simplesect or xrefsect">
                <xsl:apply-templates />
            </xsl:when>
            <xsl:otherwise>
                <xsl:element name="p">
                    <xsl:apply-templates />
                </xsl:element>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
   

    <!-- 
        Processes the content for the topic's detailed description in 
        'paramlist' mode.
    -->
    <xsl:template match="detaileddescription/para" mode="paramlist">
        <xsl:element name="p">
            <xsl:apply-templates mode="paramlist" />
            <!--<xsl:apply-templates />-->
        </xsl:element>
    </xsl:template>

    <!-- 
        Do not process parameterlist elements in 'paramlist' mode.
    -->
    <xsl:template match="detaileddescription/para/parameterlist" mode="paramlist" />

    <!-- 
        Do not process simplesect elements in 'paramlist' mode.
    -->
    <xsl:template match="detaileddescription/para/simplesect" mode="paramlist" />

    <xsl:template name="structdescription" />

    <!-- 
        Processes paragraph content.
    -->
    <xsl:template match="para">
        <xsl:choose>
            <xsl:when test="parent::listitem">
                <xsl:apply-templates />
            </xsl:when>
            <xsl:when test="child::xrefsect">
                <xsl:apply-templates select="xrefsect" />
            </xsl:when>
            <xsl:otherwise>
                <xsl:element name="p">
                    <xsl:apply-templates />
                </xsl:element>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template match="itemizedlist">
        <xsl:element name="ul">
            <xsl:apply-templates />
        </xsl:element>
    </xsl:template>

    <xsl:template match="orderedlist">
        <xsl:element name="ol">
            <xsl:apply-templates />
        </xsl:element>
    </xsl:template>

    <xsl:template match="listitem">
        <xsl:element name="li">
            <xsl:apply-templates />
        </xsl:element>
    </xsl:template>

    <xsl:template match="emphasis">
        <xsl:element name="i">
            <xsl:apply-templates />
        </xsl:element>
    </xsl:template>

    <xsl:template match="emphasis" mode="paramlist">
        <xsl:element name="i">
            <xsl:apply-templates />
        </xsl:element>
    </xsl:template>

    <xsl:template match="bold">
        <xsl:element name="b">
            <xsl:apply-templates />
        </xsl:element>
    </xsl:template>
    
    <xsl:template match="bold" mode="paramlist">
        <xsl:element name="b">
            <xsl:apply-templates />
        </xsl:element>
    </xsl:template>
    
    <!-- 
        Processes monospaced text.
    -->
    <xsl:template match="computeroutput">
        <xsl:choose>
            <xsl:when test="ref">
                <xsl:apply-templates />
            </xsl:when>
            <xsl:otherwise>
                <xsl:element name="codeph">
                    <!--<xsl:value-of select="."/>-->
                    <xsl:apply-templates />
                </xsl:element>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- 
        Processes monospaced text in 'paramlist' mode.
    -->
    <xsl:template match="computeroutput" mode="paramlist">
        <xsl:choose>
            <xsl:when test="ref">
                <xsl:apply-templates />
            </xsl:when>
            <xsl:otherwise>
                <xsl:element name="codeph">
                    <!--<xsl:value-of select="."/>-->
                    <xsl:apply-templates />
                </xsl:element>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- 
        Creates the topic's synopsis section.
    -->
    <xsl:template name="verbatim">
        <xsl:param name="apiType" />
        <xsl:param name="headerXMLDoc">
            <xsl:text>file:///</xsl:text>
            <xsl:variable name="headerFile"
                select="substring-before(substring-after(../location/@bodyfile, 'src/'),
                '.h')" />
            <!--<xsl:choose>
                <xsl:when test="contains(substring-after(../location/@bodyfile, 'src/'), '_')">
                    <xsl:value-of
                        select="concat(substring-before(../location/@bodyfile,
                        '/src'), '/src', '/xml/', replace($headerFile, '_', '__'), '_8h', '.xml')"
                    />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of
                        select="concat(substring-before(../location/@bodyfile, '/src'),
                        '/src', '/xml/', $headerFile, '_8h', '.xml')"
                    />
                </xsl:otherwise>
            </xsl:choose>-->
            <xsl:choose>
                <xsl:when test="contains(substring-after(../location/@bodyfile, 'src/'), '_')">
                    <xsl:value-of
                        select="concat(substring-after($srcdir, ':'), replace($headerFile, '_', '__'), '_8h', '.xml')"
                     />
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of
                        select="concat(substring-after($srcdir, ':'), $headerFile, '_8h', '.xml')"
                     />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:param>
        <xsl:if test="../../includes">
            <xsl:element name="pre">
                <xsl:attribute name="scale" select="80" />
                <xsl:for-each select="../../includes[1]">
                    <xsl:choose>
                        <xsl:when test="$headerlocn = ''">
                        <xsl:if test="@local='no'">
                            <xsl:text>#include &lt;</xsl:text>
                            <!--<xsl:value-of select="." />-->
                            <xsl:value-of
                                select="../compoundname" />
                            <xsl:text>&gt;
</xsl:text>
                        </xsl:if>
                        <xsl:if test="@local='yes'">
                            <xsl:text>#include "</xsl:text>
                            <!--<xsl:value-of select="." />-->
                            <xsl:value-of
                                select="../compoundname" />
                            <xsl:text>"
</xsl:text>
                        </xsl:if>    
                    </xsl:when>
                        <xsl:otherwise>
                    <xsl:if test="@local='no'">
                        <xsl:text>#include &lt;</xsl:text>
                        <!--<xsl:value-of select="." />-->
                        <xsl:value-of
                            select="concat($headerlocn, '/',
                            ../compoundname)" />
                        <xsl:text>&gt;
</xsl:text>
                    </xsl:if>
                    <xsl:if test="@local='yes'">
                        <xsl:text>#include "</xsl:text>
                        <!--<xsl:value-of select="." />-->
                        <xsl:value-of
                            select="concat($headerlocn, '/',
                            ../compoundname)" />
                        <xsl:text>"
</xsl:text>
                    </xsl:if>
                    </xsl:otherwise>
                        </xsl:choose>
                    </xsl:for-each>
                <xsl:text> 
</xsl:text>
            </xsl:element>
        </xsl:if>
        <xsl:choose>
            <xsl:when test="$apiType='enum'">
                <xsl:variable name="enumTag" select="location/@bodystart" />
                <xsl:variable name="enumDecl" select="location/@bodyend" />
                <xsl:element name="pre">
                    <xsl:attribute name="scale" select="80" />
                    <xsl:if
                        test="../../programlisting/codeline[@lineno =
                        $enumTag]/highlight[1] = 'typedef'">
                        <xsl:value-of
                            select="../../programlisting/codeline[@lineno =
                            $enumTag]/highlight[1]"
                         />
                    </xsl:if>
                    <xsl:text> enum </xsl:text>
                    <xsl:value-of
                        select="../../programlisting/codeline[@lineno =
                        $enumTag]/highlight/ref[@kindref = 'member']" />
                    <xsl:text>{</xsl:text>
                    <xsl:text>
</xsl:text>
                    <xsl:for-each select="enumvalue">
                        <xsl:text>      </xsl:text>
                        <xsl:value-of select="name" />
                        <xsl:if test="initializer">
                            <xsl:text> =</xsl:text>
                            <xsl:value-of select="initializer" />
                        </xsl:if>
                        <xsl:text>   
</xsl:text>
                    </xsl:for-each>
                    <xsl:text>}</xsl:text>
                    <xsl:if
                        test="../../programlisting/codeline[@lineno =
                        $enumDecl]/highlight/ref[@kindref = 'member']">
                        <xsl:text> </xsl:text>
                        <xsl:value-of
                            select="../../programlisting/codeline[@lineno =
                            $enumDecl]/highlight/ref[@kindref = 'member']"
                         />
                    </xsl:if>
                    <xsl:text>;</xsl:text>
                </xsl:element>
            </xsl:when>
            <xsl:when test="$apiType='function'">
                <xsl:element name="pre">
                    <xsl:attribute name="scale" select="80" />
                    <xsl:value-of select="definition" />
                    <xsl:value-of select="argsstring" />
                </xsl:element>
            </xsl:when>
            <xsl:when test="$apiType='typedef'">
                <xsl:element name="pre">
                    <xsl:attribute name="scale" select="80" />
                    <xsl:value-of select="definition" />
                    <xsl:text>;</xsl:text>
                </xsl:element>
            </xsl:when>
            <xsl:when test="$apiType='define'">
                <xsl:for-each select="memberdef">
                        <xsl:element name="sectiondiv">
                        <xsl:element name="pre">
                        <xsl:attribute name="scale" select="80" />
                        <xsl:element name="b"><xsl:text>#define </xsl:text>
                        <xsl:value-of select="name" />
                        <xsl:text> </xsl:text>
                        <xsl:value-of select="initializer" />
                        <xsl:text>
</xsl:text>
                    </xsl:element></xsl:element>
                    <xsl:if test="briefdescription/para">
                        <xsl:apply-templates select="briefdescription/para" />
                    </xsl:if>
                    <xsl:if test="detaileddescription/para">
                        <xsl:apply-templates select="detaileddescription/para" />
                    </xsl:if></xsl:element>
                </xsl:for-each>
            </xsl:when>
            <xsl:when test="..[@kind='struct']">
                <xsl:variable name="thisComponent" select="preceding-sibling::compoundname" />
                <xsl:variable name="thisComponentExt" select="parent::compounddef/@id" />
                <!--<xsl:variable name="thisXMLDoc"
                    select="concat(substring-before(memberdef[1]/location/@bodyfile, '/src'),
                    '/src', '/xml/', ../@id, '.xml')" />-->
                <xsl:variable name="structTag" select="memberdef[1]/location/@bodystart" />
                <xsl:variable name="structDecl" select="../location/@bodyend" />
                <xsl:variable name="structTypedef"
                    select="document(string($headerXMLDoc))/doxygen/compounddef/programlisting/codeline[@refid=$thisComponentExt
                    and @refkind='compound'][following-sibling::codeline[@lineno=$structDecl]]/highlight[@class='keyword'][1]" />
                <xsl:variable name="structTagName"
                    select="document(string($headerXMLDoc))/doxygen/compounddef/programlisting/codeline[child::highlight[child::ref[@refid=$thisComponentExt]]][following-sibling::codeline[@lineno=$structTag]][1]/highlight/ref[@refid=$thisComponentExt]" />
                <xsl:variable name="structDeclName"
                    select="document(string($headerXMLDoc))/doxygen/compounddef/programlisting/codeline[@lineno=$structDecl]/highlight/ref" />
                <xsl:element name="pre">
                    <xsl:attribute name="scale" select="80" />
                    <xsl:if
                        test="document(string($headerXMLDoc))/doxygen/compounddef/programlisting/codeline[@refid=$thisComponentExt
                        and
                        @refkind='compound'][following-sibling::codeline[@lineno=$structDecl]]/highlight[@class='keyword'][1]
                        = 'typedef'">
                        <xsl:value-of select="$structTypedef" />
                        <xsl:text> </xsl:text>
                    </xsl:if>
                    <xsl:text>struct </xsl:text>
                    <xsl:value-of select="$structTagName" />
                    <xsl:text> {</xsl:text>
                    <xsl:text>
</xsl:text>

                    <!--<xsl:for-each select="document($targetXMLDoc)/doxygen/compounddef/programlisting/codeline/@refid">-->
                    <!--<xsl:for-each select="./memberdef/@id">
                        <xsl:call-template name="processCodeline">
                            <xsl:with-param name="codelineID" select="." />
                            <xsl:with-param name="targetXMLDoc" select="$headerXMLDoc"/>
                            </xsl:call-template>-->
                    <xsl:for-each select="./memberdef">
                        <xsl:text>    </xsl:text>
                        <xsl:value-of select="type" />
                        <xsl:text> </xsl:text>
                        <xsl:value-of select="name" />
                        <xsl:text> </xsl:text>
                        <xsl:value-of select="argsstring" />
                        <xsl:text>;</xsl:text>
                        <xsl:text>
</xsl:text>
                    </xsl:for-each>
                    <xsl:text>}</xsl:text>
                    <xsl:value-of select="$structDeclName" />
                    <xsl:text>;</xsl:text>
                </xsl:element>
            </xsl:when>
        </xsl:choose>
    </xsl:template>

    <!-- Process parameters when part of a 'define' memberdef.
    
         [Using a named template to prevent side effects so close
         to a release date.]
    -->
    <xsl:template name="param_defname">
        <xsl:element name="codeph">
            <xsl:value-of select="." />
        </xsl:element>
    </xsl:template>

    <!-- Process deprecated items -->
    <xsl:template match="xrefsect">
        <xsl:apply-templates />
    </xsl:template>

    <!-- Process xreftitle elements, don't process todo items. -->
    <xsl:template match="xreftitle">
        <xsl:choose>
            <xsl:when test="contains(., 'Todo')">
                <!-- Do nothing. --> </xsl:when>
            <xsl:otherwise>
                <xsl:element name="p">
                    <xsl:element name="b">
                        <xsl:value-of select="." />
                        <xsl:text>:</xsl:text>
                    </xsl:element>
                </xsl:element>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- Process xrefdescription elements, don't process todo items. -->
    <xsl:template match="xrefdescription">
        <xsl:choose>
            <xsl:when test="contains(parent::*, 'Todo')">
                <!-- Do nothing. --> </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- Process code listings. -->
    <xsl:template match="programlisting">
        <xsl:element name="pre">
            <xsl:call-template name="codeline-doxy" />
        </xsl:element>
        <!--<xsl:apply-templates select="programlisting" />-->
    </xsl:template>

    <xsl:template name="codeline-doxy">
        <xsl:apply-templates />
    </xsl:template>

    <xsl:template match="highlight">
        <!--<xsl:value-of select="." />-->
        <xsl:apply-templates />
    </xsl:template>

    <xsl:template match="sp">
        <xsl:text>&#xA0;</xsl:text>
        <!--<xsl:text>&nbsp;</xsl:text>-->
    </xsl:template>

    <!-- Link handling. -->
    <xsl:template match="ulink">
        <xsl:element name="xref">
            <xsl:attribute name="href" select="@url" />
            <xsl:choose>
                <xsl:when test="contains(@url, 'http')">
                    <xsl:attribute name="scope">
                        <xsl:text>external</xsl:text>
                    </xsl:attribute>
                </xsl:when>
                <xsl:otherwise />
            </xsl:choose>
            <xsl:value-of select="." />
        </xsl:element>
    </xsl:template>

    <xsl:template match="ref">
        <xsl:param name="apiname">
            <!-- Variables used in the contruction of xref links to enum values:
             1. memberkind holds the value of member/@kind in index.xml 
                associated with the @refid attribute of the current context. 
             2. componentid holds the value of @refid attribute. -->
            <xsl:choose>
                <xsl:when test="contains(., '(')">
                    <!--<xsl:variable name="apiname">-->
                    <xsl:value-of select="substring-before(., '(')" />
                    <!--</xsl:variable>-->
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="." />
                </xsl:otherwise>
            </xsl:choose>
        </xsl:param>
        <!--<xsl:variable name="memberkind" select="doc(concat($srcdir, 'index.xml'))/doxygenindex/compound/member/name[.]/parent::member/@kind" />-->
        <xsl:variable name="memberkind"
            select="doc(concat($srcdir, 'index.xml'))/doxygenindex/compound/member[name=$apiname]/@kind" />
        <xsl:variable name="componentid" select="@refid" />
        <!--<xsl:variable name="memberparent" 
            select="doc(concat($srcdir, 'index.xml'))/doxygenindex/compound/member[@kind='enum'][following-sibling::member[name=$apiname][preceding-sibling::member[@kind='enum']]][1]/name" />-->
        <xsl:choose>
            <xsl:when test="contains(., '.h')">
                <xsl:element name="filepath">
                    <xsl:value-of select="." />
                </xsl:element>
            </xsl:when>
            <xsl:when test="//compounddef[1]/@kind = 'file'">
                <xsl:element name="xref">
                    <xsl:variable name="hrefcontent">
                        <xsl:choose>
                            <xsl:when test="contains(@refid, '_1')">
                                <xsl:choose>
                                    <xsl:when test="contains(., '(')">
                                        <xsl:value-of select="substring-before(., '(')" />
                                    </xsl:when>
                                    <xsl:when test="contains(@refid, 'struct')">
                                        <xsl:value-of select="substring-before(@refid, '_1')" />
                                    </xsl:when>
                                    <!-- Generate href for link to enum value. -->
                                    <xsl:when test="$memberkind = 'enumvalue'">
                                        <xsl:variable name="localapiname" select="." />
                                        <!--<xsl:value-of select="if (ancestor::memberdef/detaileddescription/sect1) then concat(concat(//enumvalue[@id = $componentid]/parent::memberdef/detaileddescription/sect1/@id, '.xml'), '#', 'at_', substring-after(//enumvalue[@id = $componentid]/parent::memberdef/name, '@'), '/', @refid) else concat(concat(//enumvalue[@id = $componentid]/parent::memberdef/name, '.xml'), '#', 'at_', substring-after(//enumvalue[@id = $componentid]/parent::memberdef/name, '@'), '/', @refid)" />-->
                                        <xsl:variable name="anonenum">
                                        <xsl:value-of
                                            select="if (ancestor::memberdef/detaileddescription/sect1) 
                                            then concat(concat(//enumvalue[@id = $componentid]/parent::memberdef/detaileddescription/sect1/@id, '.xml'), '#', 'at_', substring-after(//enumvalue[@id = $componentid]/parent::memberdef/name, '@'), '/', @refid) 
                                            else concat(concat(distinct-values(doc(concat($srcdir, 'index.xml'))/doxygenindex/compound/member[@kind='enum'][following-sibling::member[name=$localapiname][preceding-sibling::member[@kind='enum']]][last()]/name), '.xml'), '#', concat(concat(distinct-values(doc(concat($srcdir, 'index.xml'))/doxygenindex/compound/member[@kind='enum'][following-sibling::member[name=$localapiname][preceding-sibling::member[@kind='enum']]][last()]/name), '__'), @refid))" />
                                        <!--Good: <xsl:value-of
                                            select="if (ancestor::memberdef/detaileddescription/sect1) 
                                                    then concat(concat(//enumvalue[@id = $componentid]/parent::memberdef/detaileddescription/sect1/@id, '.xml'), '#', 'at_', substring-after(//enumvalue[@id = $componentid]/parent::memberdef/name, '@'), '/', @refid) 
                                                    else concat(concat(//enumvalue[@id = $componentid]/parent::memberdef/name, '.xml'), '#', concat(concat(//enumvalue[@id = $componentid]/parent::memberdef/name, '__'), @refid))"
                                         />-->
                                        </xsl:variable>
                                        <xsl:choose>
                                            <xsl:when test="contains($anonenum, '@')">
                                                <xsl:value-of select="concat(concat(//enumvalue[@id = $componentid]/parent::memberdef/detaileddescription/sect1/@id, '.xml'), '#', 'at_', substring-after(//enumvalue[@id = $componentid]/parent::memberdef/name, '@'), '/', @refid)" />
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:value-of select="$anonenum" />
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </xsl:when>
                                    <!--<xsl:when test="$memberkind = 'enumvalue'">
                                        <xsl:value-of select="concat(concat(//enumvalue[@id = $componentid]/parent::memberdef/detaileddescription/sect1/@id, '.xml'), '#', 'at_', substring-after(//enumvalue[@id = $componentid]/parent::memberdef/name, '@'), '/', @refid)" />
                                    </xsl:when>-->
                                    <!-- Generate href for link to function (will be needed to handle overloaded functions. -->
                                    <xsl:when test="$memberkind = 'function'">
                                        <xsl:value-of
                                            select="concat(concat(., '.xml'), '#',  @refid)" />
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:value-of select="." />
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:when>
                            <xsl:when test="contains(@refid, 'struct')">
                                <xsl:value-of select="@refid" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="@refid" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:attribute name="href">
                        <!-- If link target is an element in a topic (#), don't append
                             the xml file name extrension.-->
                        <xsl:choose>
                            <xsl:when test="contains($hrefcontent, '#')">
                                <xsl:value-of select="$hrefcontent" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="concat($hrefcontent, '.xml')" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:attribute>
                    <xsl:choose>
                        <xsl:when test="contains(@url, 'http')">
                            <xsl:attribute name="scope">
                                <xsl:text>external</xsl:text>
                            </xsl:attribute>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:attribute name="scope">
                                <xsl:text>peer</xsl:text>
                            </xsl:attribute>
                        </xsl:otherwise>
                    </xsl:choose>
                    <xsl:choose>
                        <xsl:when test="$memberkind = 'enumvalue'">
                            <xsl:element name="codeph">
                                <xsl:value-of select="." />
                            </xsl:element>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="." />
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:element>
            </xsl:when>
            <xsl:when test="//compounddef[1]/@kind = 'struct'">
                <xsl:element name="xref">
                    <xsl:variable name="hrefcontent">
                        <xsl:choose>
                            <xsl:when test="contains(@refid, '_1')">
                                <xsl:choose>
                                    <xsl:when test="contains(., '(')">
                                        <xsl:value-of select="substring-before(., '(')" />
                                    </xsl:when>
                                    <!--<xsl:when test="not(contains(., '('))">
                                        <xsl:value-of select="." />
                                    </xsl:when>-->
                                    <xsl:when test="contains(@refid, 'struct')">
                                        <xsl:value-of select="substring-before(@refid, '_1')" />
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:value-of select="." />
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:when>
                            <xsl:when test="contains(@refid, 'struct')">
                                <xsl:value-of select="@refid" />
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="@refid" />
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:attribute name="href" select="concat($hrefcontent, '.xml')" />
                    <xsl:choose>
                        <xsl:when test="contains(@url, 'http')">
                            <xsl:attribute name="scope">
                                <xsl:text>external</xsl:text>
                            </xsl:attribute>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:attribute name="scope">
                                <xsl:text>local</xsl:text>
                            </xsl:attribute>
                        </xsl:otherwise>
                    </xsl:choose>
                    <xsl:value-of select="." />
                </xsl:element>
            </xsl:when>
            <xsl:otherwise />
        </xsl:choose>
    </xsl:template>

    <!-- 
        Extension for Screen lib ref plug-in.
        
        Templates to create tables that classify functions by their execution
        type.
    -->
    <!-- Top-level, global variable 'funcid' -->
    <xsl:variable name="funcid"
        select="/doxygen/compounddef[@kind='file']/sectiondef/memberdef[@kind='function']/@id" />

    <!-- Create funtion types topic and call named template to create 
         individual tables. -->
    <xsl:template name="funcTypesTable_driver">
        <xsl:variable name="outpath">
            <xsl:value-of select="concat($outdir,  'function_types', '.xml')" />
        </xsl:variable>
        <xsl:result-document doctype-public="-//QNX//Specialization Reference//EN"
            doctype-system="http://www.qnx.com/dita/xml/1.2/concept.dtd" encoding="utf-8"
            href="file:///{$outpath}" method="xml">
            <xsl:comment>The content of this topic is generated automatically.</xsl:comment>
            <xsl:element name="concept">
                <xsl:attribute name="id">
                    <xsl:text>screen_function_types</xsl:text>
                </xsl:attribute>
                <xsl:attribute name="xml:lang">
                    <xsl:text>en-us</xsl:text>
                </xsl:attribute>
                <xsl:element name="title">
                    <xsl:text>Function types</xsl:text>
                </xsl:element>
                <xsl:element name="shortdesc">
                    <xsl:text>The tables in this section list the type of each function, where the type indicates the expected timeliness of each function call. </xsl:text>
                </xsl:element>
                <xsl:element name="conbody">
                    <!-- Tables, create table for each function type. -->
                    <xsl:element name="section">
                        <xsl:element name="title">
                            <xsl:text>Contexts</xsl:text>
                        </xsl:element>
                        <xsl:call-template name="funcTypesTable">
                            <xsl:with-param name="functype">
                                <xsl:text>contexts</xsl:text>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:element>
                    <xsl:element name="section">
                        <xsl:element name="title">
                            <xsl:text>Devices</xsl:text>
                        </xsl:element>
                        <xsl:call-template name="funcTypesTable">
                            <xsl:with-param name="functype">
                                <xsl:text>devices</xsl:text>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:element>
                    <xsl:element name="section">
                        <xsl:element name="title">
                            <xsl:text>Displays</xsl:text>
                        </xsl:element>
                        <xsl:call-template name="funcTypesTable">
                            <xsl:with-param name="functype">
                                <xsl:text>displays</xsl:text>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:element>
                    <xsl:element name="section">
                        <xsl:element name="title">
                            <xsl:text>Events</xsl:text>
                        </xsl:element>
                        <xsl:call-template name="funcTypesTable">
                            <xsl:with-param name="functype">
                                <xsl:text>events</xsl:text>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:element>
                    <xsl:element name="section">
                        <xsl:element name="title">
                            <xsl:text>Windows</xsl:text>
                        </xsl:element>
                        <xsl:call-template name="funcTypesTable">
                            <xsl:with-param name="functype">
                                <xsl:text>windows</xsl:text>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:element>
                    <xsl:element name="section">
                        <xsl:element name="title">
                            <xsl:text>Groups</xsl:text>
                        </xsl:element>
                        <xsl:call-template name="funcTypesTable">
                            <xsl:with-param name="functype">
                                <xsl:text>groups</xsl:text>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:element>
                    <xsl:element name="section">
                        <xsl:element name="title">
                            <xsl:text>Pixmaps</xsl:text>
                        </xsl:element>
                        <xsl:call-template name="funcTypesTable">
                            <xsl:with-param name="functype">
                                <xsl:text>pixmaps</xsl:text>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:element>
                    <xsl:element name="section">
                        <xsl:element name="title">
                            <xsl:text>Buffers</xsl:text>
                        </xsl:element>
                        <xsl:call-template name="funcTypesTable">
                            <xsl:with-param name="functype">
                                <xsl:text>buffers</xsl:text>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:element>
                    <xsl:element name="section">
                        <xsl:element name="title">
                            <xsl:text>Blits</xsl:text>
                        </xsl:element>
                        <xsl:call-template name="funcTypesTable">
                            <xsl:with-param name="functype">
                                <xsl:text>blits</xsl:text>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:element>
                    <xsl:element name="section">
                        <xsl:element name="title">
                            <xsl:text>Effects</xsl:text>
                        </xsl:element>
                        <xsl:call-template name="funcTypesTable">
                            <xsl:with-param name="functype">
                                <xsl:text>effects</xsl:text>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:element>
                </xsl:element>
            </xsl:element>
        </xsl:result-document>
    </xsl:template>

    <!-- Creates funtion/exectution type tables for Screen lib ref.  -->
    <xsl:template name="funcTypesTable">
        <xsl:param name="functype" />
        <xsl:element name="table">
            <xsl:attribute name="colsep">
                <xsl:text>1</xsl:text>
            </xsl:attribute>
            <xsl:attribute name="rowsep">
                <xsl:text>1</xsl:text>
            </xsl:attribute>
            <xsl:element name="tgroup">
                <xsl:attribute name="cols">
                    <xsl:text>2</xsl:text>
                </xsl:attribute>
                <xsl:element name="thead">
                    <xsl:element name="row">
                        <xsl:element name="entry">Function</xsl:element>
                        <xsl:element name="entry">Function type</xsl:element>
                    </xsl:element>
                </xsl:element>
                <xsl:element name="tbody">
                    <!-- Create rows with content for every function that 
                         matches the function type. -->
                    <xsl:for-each select="$funcid">
                        <xsl:if test="contains(., $functype)">
                            <xsl:element name="row">
                                <xsl:element name="entry">
                                    <xsl:variable name="funcname">
                                        <xsl:value-of select="../name" />
                                    </xsl:variable>
                                    <xsl:element name="xref">
                                        <xsl:attribute name="href">
                                            <xsl:value-of select="concat($funcname, '.xml')" />
                                        </xsl:attribute>
                                        <xsl:attribute name="scope">
                                            <xsl:text>local</xsl:text>
                                        </xsl:attribute>
                                        <xsl:element name="apiname">
                                            <xsl:value-of select="$funcname" />
                                            <xsl:text>()</xsl:text>
                                        </xsl:element>
                                    </xsl:element>
                                </xsl:element>
                                <xsl:element name="entry">
                                    <xsl:value-of select="../detaileddescription/para/ulink" />
                                </xsl:element>
                            </xsl:element>
                        </xsl:if>
                    </xsl:for-each>
                </xsl:element>
            </xsl:element>
        </xsl:element>

    </xsl:template>

    <!-- <xsl:when test="$apiType='define'">
                <xsl:for-each select="memberdef">
                    <xsl:element name="pre">
                        <xsl:text>#define </xsl:text>
                        <xsl:value-of select="name" />
                        <xsl:text> </xsl:text>
                        <xsl:value-of select="initializer" />
                        <xsl:text>
</xsl:text>
                    </xsl:element>
                    
                    <xsl:if test="briefdescription/para">
                        <xsl:apply-templates select="briefdescription/para" />
                    </xsl:if>
                    <xsl:if test="detaileddescription/para">
                        <xsl:apply-templates select="detaileddescription/para" />
                    </xsl:if>
                </xsl:for-each>
            </xsl:when>    -->

</xsl:transform>
